#!/usr/bin/env python

'''
	This is a script to convert rndf file into waypoints dictionary,
	control points dictionary, and adjacency list. Some of the entries
	in the control points dictionary have to be modified if the bezier
	curve generated by a control points entry violates the deviation and 
	curvature constraint.

	Usage:
		# import this script 
		# create an instance and initialize with layout name (ex: example.rndf)
		
		makedicts = makeDicts('example')
		

		# call the method 'createCPDict()' to control points dictionary
		makedicts.createCPDict()

		
		# call the method 'createAdjListWaypointsDict()' to create adjacency list
		# and waypoints dictionary
		
		makedicts.createAdjListWaypointsDict()

		
		# clean files that are created in the process
		makedicts.clean()

'''


import re
from collections import OrderedDict
import StringIO
import networkx as nx
import numpy as np
import time
from bezier_interpolation_def import *
from readrndf import *
import os
from distutils.dir_util import *



def wp_dicts(filename):

	'''
		this function takes rndf file as an input and returns 
		waypoints dictionary and adjacency list as output
	'''
	rndf = segmentsDict(filename)
	a = rndf.dict()
	wpd = OrderedDict()
	stoppoints = []
	adjl = OrderedDict()
	graph = nx.DiGraph()
	for k,v in a.items():
		seg = rndfSegments(v)
		seg.info()
		ld = seg.laneDict()
		for key,val in ld.items():
			lane = rndfLanes(val)
			lane.info()
			for k in lane.waypointDict:
				wpd[k] = lane.waypointDict[k]
			for sp in lane.stopPoints:
				stoppoints.append(sp)
			lwpd = lane.waypointDict
			wpk = lwpd.keys()
			for i in range(len(wpk)-1):
				try:
					adjl[wpk[i]].append(wpk[i+1])
				except KeyError:
					adjl[wpk[i]] = [wpk[i+1]]
				graph.add_edge(wpk[i],wpk[i+1])
			for exitpoint in lane.exitPoints:
				try:
					adjl[exitpoint[0]].append(exitpoint[1])
				except KeyError:
					adjl[exitpoint[0]] = [exitpoint[1]]
				graph.add_edge(exitpoint[0],exitpoint[1])
	for k in wpd.keys():
		if k in stoppoints:
			wpd[k].append(1)
		else:
			wpd[k].append(0)
	return adjl,wpd

class makeDicts:

	'''
		This class has methods to create adjacent list, waypoints and control points dictionaries
	'''

	def __init__(self,layout):

		'''
			Initialize the class with layout name
			(layout name is the name of the file without .rndf extesion
			only 'spiral' is the file name is spiral.rndf)
		'''

		self.layout = layout

		# load all the segments into a dictionary 
		rndf = segmentsDict('src/{}.rndf'.format(self.layout))
		a = rndf.dict()

		# load all the waypoints into a dictionary
		rndfwp = waypointsDict('src/{}.rndf'.format(self.layout))
		self.wpd = rndfwp.dict()

		self.bezsegs = []

		# crate a graph to generate the adjacency list
		graph = nx.DiGraph()
		for k,v in a.items():
			# print v
			seg = rndfSegments(v)
			seg.info()
			ld = seg.laneDict()
			for key,val in ld.items():
				lane = rndfLanes(val)
				lane.info()
				lwpd = lane.waypointDict
				wpk = lwpd.keys()
				for i in range(len(wpk)-1):
					graph.add_edge(wpk[i],wpk[i+1])
				for exitpoint in lane.exitPoints:
					graph.add_edge(exitpoint[0],exitpoint[1])

		self.adjacencyList = {}
		for t in nx.generate_adjlist(graph):
			adl = t.split()
			key = adl[0]
			val = adl[1:]
			self.adjacencyList[key] = val

	

	def createCPDict(self):

		'''
			This method creates a control points dictionary
		'''

		def createBeziersList():

			def keyOf(val,d):
				keys = []
				for k,v in d.items():
					if val in v:
						keys.append(k)
				return keys

			# to store sets of four consecutive points which will be used to generate
			# control points
			fns = open("bezsegs_ncp.txt","w")
			for adkey in self.adjacencyList.keys():
				currentNode = adkey
				for fs in self.adjacencyList[currentNode]:
					parentNode = keyOf(currentNode,self.adjacencyList)
					for pn in parentNode:
						firstSuccessor = fs
						secondSuccessor = self.adjacencyList[fs]
						for ss in secondSuccessor:
							if(self.wpd[currentNode]==self.wpd[firstSuccessor]):
								fns.write(str([pn])+"\t"+str([firstSuccessor])+"\t"+str([ss])+"\t"+str(self.adjacencyList[ss])+"\n")
								self.bezsegs.append([self.wpd[pn],self.wpd[firstSuccessor],self.wpd[ss],self.wpd[self.adjacencyList[ss][0]]])
							elif(self.wpd[firstSuccessor] == self.wpd[ss]):
								self.bezsegs.append([self.wpd[pn],self.wpd[currentNode],self.wpd[firstSuccessor],self.wpd[self.adjacencyList[ss][0]]])
								fns.write(str([pn])+"\t"+str([currentNode])+"\t"+str([firstSuccessor])+"\t"+str(self.adjacencyList[ss][0])+"\n")
							else:
								self.bezsegs.append([self.wpd[pn],self.wpd[currentNode],self.wpd[firstSuccessor],self.wpd[ss]])
								fns.write(str([pn])+"\t"+str([currentNode])+"\t"+str([firstSuccessor])+"\t"+str([ss])+"\n")
			fns.close()

		def createCPList():
			'''
				This function will generate control points for the segements stored
			'''
			fn = open("controlpoints_ncp.txt","w")
			for bs in self.bezsegs:
				cps = [bs[0],bs[1],bs[2],bs[3]]
				kk,md,mc = generateK(cps,1,0.1)
				cps = np.array(cps)
				cp1,cp2 = generate_cps(bs[0],bs[1],bs[2],bs[3],K=kk)
				Bx,By = generate_curve(bs[1],cp1,cp2,bs[2])
				if(md>1 or mc>0.1):
					fn.write(str([round(elem,3) for elem in bs[1]])+"|"+\
							str([round(elem,3) for elem in cp1])+"|"+\
							str([round(elem,3) for elem in cp2])+"|"+\
							str([round(elem,3) for elem in bs[2]])+"| "+\
							str([round(kk,3),round(md,3),round(mc,3)])+"|*****\n")
				else:
					fn.write(str([round(elem,3) for elem in bs[1]])+"|"+\
						str([round(elem,3) for elem in cp1])+"|"+\
						str([round(elem,3) for elem in cp2])+"|"+\
						str([round(elem,3) for elem in bs[2]])+"| "+\
						str([round(kk,3),round(md,3),round(mc,3)])+"\n")
			fn.close()

		createBeziersList()
		createCPList()

		# read the segements
		bezFile = open('bezsegs_ncp.txt','r')
		bezLines = bezFile.readlines()

		# read control points list
		cpFile = open('controlpoints_ncp.txt','r')
		cpLines = cpFile.readlines()

		try:
			cpdict = open('dicts/{}/controlpoints_dict.txt'.format(self.layout),'w')
		except IOError:
			mkpath('./dicts/{}'.format(self.layout))
			cpdict = open('dicts/{}/controlpoints_dict.txt'.format(self.layout),'w')

		# match the segments and control points to add to control points dictionary
		for i in range(len(cpLines)):
			bzs = bezLines[i].split()
			cps = cpLines[i].split('|')
			if(len(cps)==6):
				cpdict.write('*'+('|').join([bzs[1][2:-2],bzs[2][2:-2]])+'|'+('|').join(cps[:-1])+'|\n')
			else:
				cpdict.write(('|').join([bzs[1][2:-2],bzs[2][2:-2]])+'|'+('|').join(cps[:-1])+'|\n')

		bezFile.close()
		cpFile.close()
		cpdict.close()

	def createAdjListWaypointsDict(self):

		# this is to create adjacency list and waypoints dictionaries

		adjl,wpd = wp_dicts('src/{}.rndf'.format(self.layout))
		try:
			wpdf = open('dicts/{}/waypoints_dict.txt'.format(self.layout),'a')
			adjf = open('dicts/{}/adjacencylist_dict.txt'.format(self.layout),'a')
		except IOError:
			mkpath('./dicts/{}'.format(self.layout))
			wpdf = open('dicts/{}/waypoints_dict.txt'.format(self.ayout),'a')
			adjf = open('dicts/{}/adjacencylist_dict.txt'.format(self.layout),'a')
			
		for i in adjl.keys():
			adjf.write(str(i)+':'+str(adjl[i])+'\n')

		for i in wpd.keys():
			val = wpd[i]
			wpdf.write(str(i)+'|'+str(val[0])+'|'+str(val[1])+'|'+str(val[3])+'|'+str(val[2])+'|\n')

		wpdf.close()
		adjf.close()

	def clean(self):
		# remove the files that are created in the process
		os.remove('./bezsegs_ncp.txt')
		os.remove('./controlpoints_ncp.txt')

def createDictsForAllFiles():

	# this function 

	fl = os.listdir('./src')
	for i in fl:
		print i
		if '~' in i:
			pass
		else:
			fln = i.split('.')[0]
		# layout = raw_input('Enter file name:: ')
		layout = fln

		md = makeDicts(layout)
		md.createCPDict()
		md.createAdjListWaypointsDict()
		md.clean()

if __name__ == '__main__':
	createDictsForAllFiles()